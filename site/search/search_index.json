{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IOSonata Documentation","text":"<p>Welcome to the IOSonata documentation!</p>"},{"location":"class/","title":"Classes","text":"<p>::: include     handler: c     selection:       glob: \"*.h\"</p>"},{"location":"functions/","title":"Functions","text":"<p>::: include     handler: c     selection:       glob: \"*.h\"</p>"},{"location":"Device/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct __device_intrf Device interface data structure. </li> </ul>"},{"location":"Device/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir include <ul> <li>file device.h Generic device base class. </li> <li>file device_intrf.h Generic data transfer interface class. </li> </ul> </li> </ul>"},{"location":"Device/group__device__intrf/","title":"Group device_intrf","text":"<p>Modules &gt; device_intrf</p>"},{"location":"Device/group__device__intrf/#classes","title":"Classes","text":"Type Name struct __device_intrf Device interface data structure."},{"location":"Device/group__device__intrf/#public-types","title":"Public Types","text":"Type Name enum DEVINTRF_EVT Device interface event types. typedef enum __Dev_Intrf_Type DEVINTRF_TYPE Enumerating interface types. typedef int(* DevIntrfEvtHandler_t Event handler callback. typedef struct __device_intrf DevIntrf_t Device Interface forward data structure type definition. This structure is the base object. Pointer to an instance of this is passed to all function calls. See structure definition bellow for more details. enum __Dev_Intrf_Type Enumerating interface types."},{"location":"Device/group__device__intrf/#public-functions","title":"Public Functions","text":"Type Name int DeviceIntrfRead (DevIntrf_t *const pDev, uint32_t DevAddr, uint8_t * pAdCmd, int AdCmdLen, uint8_t * pRxBuff, int RxLen) Device read transfer. int DeviceIntrfRx (DevIntrf_t *const pDev, uint32_t DevAddr, uint8_t * pBuff, int BuffLen) Full receive data sequence. int DeviceIntrfTx (DevIntrf_t *const pDev, uint32_t DevAddr, uint8_t * pData, int DataLen) Full transmit data sequence. void DeviceIntrfTxComplete (DevIntrf_t *const pDev) Signal Tx transfer completed. int DeviceIntrfWrite (DevIntrf_t *const pDev, uint32_t DevAddr, uint8_t * pAdCmd, int AdCmdLen, uint8_t * pData, int DataLen) Device write transfer."},{"location":"Device/group__device__intrf/#public-static-functions","title":"Public Static Functions","text":"Type Name void DeviceIntrfDisable (DevIntrf_t *const pDev) Disable interface. Put the interface in lowest power mode. void DeviceIntrfEnable (DevIntrf_t *const pDev) Wake up the interface. void * DeviceIntrfGetHandle (DevIntrf_t *const pDev)  uint32_t DeviceIntrfGetRate (DevIntrf_t *const pDev) Get data rate of the interface in Hertz. This is not a clock frequency but rather the transfer frequency (number of transfers per second). It has meaning base on the implementation as bits/sec or bytes/sec or whatever the case. DEVINTRF_TYPE DeviceIntrfGetType (DevIntrf_t *const pDev) Get interface type. void DeviceIntrfPowerOff (DevIntrf_t *const pDev) Power off interface completely for power saving. void DeviceIntrfReset (DevIntrf_t *const pDev) This function perform a reset of interface. int DeviceIntrfRxData (DevIntrf_t *const pDev, uint8_t * pBuff, int BuffLen) Receive data into pBuff passed in parameter. Assuming StartRx was called prior calling this function to get the actual data. uint32_t DeviceIntrfSetRate (DevIntrf_t *const pDev, uint32_t Rate) Set data rate of the interface in Hertz. bool DeviceIntrfStartRx (DevIntrf_t *const pDev, uint32_t DevAddr) Prepare start condition to receive data with subsequence RxData. bool DeviceIntrfStartTx (DevIntrf_t *const pDev, uint32_t DevAddr) Prepare start condition to transfer data with subsequence TxData. void DeviceIntrfStopRx (DevIntrf_t *const pDev) Completion of read data phase. void DeviceIntrfStopTx (DevIntrf_t *const pDev) Completion of sending data via TxData. int DeviceIntrfTxData (DevIntrf_t *const pDev, uint8_t * pData, int DataLen) Transfer data from pData passed in parameter. Assuming StartTx was called prior calling this function to send the actual data."},{"location":"Device/group__device__intrf/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Device/group__device__intrf/#enum-devintrf_evt","title":"enum DEVINTRF_EVT","text":"<pre><code>enum DEVINTRF_EVT {\n    DEVINTRF_EVT_RX_TIMEOUT,\n    DEVINTRF_EVT_RX_DATA,\n    DEVINTRF_EVT_RX_FIFO_FULL,\n    DEVINTRF_EVT_TX_TIMEOUT,\n    DEVINTRF_EVT_TX_READY,\n    DEVINTRF_EVT_TX_FIFO_EMPTY,\n    DEVINTRF_EVT_STATECHG,\n    DEVINTRF_EVT_READ_RQST,\n    DEVINTRF_EVT_WRITE_RQST,\n    DEVINTRF_EVT_COMPLETED\n};\n</code></pre>"},{"location":"Device/group__device__intrf/#typedef-devintrf_type","title":"typedef DEVINTRF_TYPE","text":"<pre><code>typedef enum __Dev_Intrf_Type DEVINTRF_TYPE;\n</code></pre>"},{"location":"Device/group__device__intrf/#typedef-devintrfevthandler_t","title":"typedef DevIntrfEvtHandler_t","text":"<p>Event handler callback. </p> <pre><code>typedef int(* DevIntrfEvtHandler_t) (DevIntrf_t *const pDev, DEVINTRF_EVT EvtId, uint8_t *pBuffer, int Len);\n</code></pre> <p>This is normally being called within interrupts, avoid blocking</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Device handle </li> <li><code>EvtId</code> : Event code </li> <li><code>pBuffer</code> : In/Out Buffer containing data  on DEVINTRF_EVT_RX_TIMEOUT &amp; DEVINTRF_EVT_RXDATA, pBuffer contains data received. If driver implements CFIFO, this parameter is NULL with BufferLen indicating total data in FIFO.  on DEVINTRF_EVT_TX_READY, pBuffer contains data to be transmit with max length BufferLen. If driver implements CFIFO, this parameter is NULL and BufferLen indicates amount of data stored in FIFO  on DEVINTRF_EVT_STATECHG, pBuffer contains state data. This is implementation specific for example UART implementation would contains line state info.</li> <li><code>Len</code> : Max buffer length. See above description</li> </ul> <p>Returns:</p> <p>Number of bytes processed. Implementation specific.  in case of FIFO_FULL events, FIFO will be pushed out if return value is zero </p>"},{"location":"Device/group__device__intrf/#typedef-devintrf_t","title":"typedef DevIntrf_t","text":"<pre><code>typedef struct __device_intrf DevIntrf_t;\n</code></pre>"},{"location":"Device/group__device__intrf/#enum-__dev_intrf_type","title":"enum __Dev_Intrf_Type","text":"<pre><code>enum __Dev_Intrf_Type {\n    DEVINTRF_TYPE_UNKOWN,\n    DEVINTRF_TYPE_BT,\n    DEVINTRF_TYPE_ETH,\n    DEVINTRF_TYPE_I2C,\n    DEVINTRF_TYPE_CEL,\n    DEVINTRF_TYPE_SPI,\n    DEVINTRF_TYPE_QSPI,\n    DEVINTRF_TYPE_UART,\n    DEVINTRF_TYPE_USB,\n    DEVINTRF_TYPE_WIFI,\n    DEVINTRF_TYPE_I2S,\n    DEVINTRF_TYPE_PDM,\n    DEVINTRF_TYPE_OSPI\n};\n</code></pre>"},{"location":"Device/group__device__intrf/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Device/group__device__intrf/#function-deviceintrfread","title":"function DeviceIntrfRead","text":"<p>Device read transfer. </p> <pre><code>int DeviceIntrfRead (\n    DevIntrf_t *const pDev,\n    uint32_t DevAddr,\n    uint8_t * pAdCmd,\n    int AdCmdLen,\n    uint8_t * pRxBuff,\n    int RxLen\n) \n</code></pre> <p>A device read transfer usually starts with a write of a command or register address. Then follows with a read data results. This function encapsulate that functionality.</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> <li><code>DevAddr</code> : The device selection id scheme </li> <li><code>pAdCmd</code> : Pointer to buffer containing address or command code to send </li> <li><code>AdCmdLen</code> : Size of addr/Cmd in bytes </li> <li><code>pRxBuff</code> : Pointer to memory area to receive data. </li> <li><code>RxLen</code> : Length of buffer memory in bytes</li> </ul> <p>Returns:</p> <p>Number of bytes read </p>"},{"location":"Device/group__device__intrf/#function-deviceintrfrx","title":"function DeviceIntrfRx","text":"<p>Full receive data sequence. </p> <pre><code>int DeviceIntrfRx (\n    DevIntrf_t *const pDev,\n    uint32_t DevAddr,\n    uint8_t * pBuff,\n    int BuffLen\n) \n</code></pre> <p>This function does full receive data sequence by calling StartRx, RxData, StopRx.</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> <li><code>DevAddr</code> : The device selection id scheme </li> <li><code>pBuff</code> : Pointer to memory area to receive data. </li> <li><code>BuffLen</code> : Length of buffer memory in bytes</li> </ul> <p>Returns:</p> <p>Number of bytes read </p>"},{"location":"Device/group__device__intrf/#function-deviceintrftx","title":"function DeviceIntrfTx","text":"<p>Full transmit data sequence. </p> <pre><code>int DeviceIntrfTx (\n    DevIntrf_t *const pDev,\n    uint32_t DevAddr,\n    uint8_t * pData,\n    int DataLen\n) \n</code></pre> <p>This function does full transmit data sequence by calling StartTx, TxData, StopTx.</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> <li><code>DevAddr</code> : The device selection id scheme </li> <li><code>pData</code> : Pointer to data to send. </li> <li><code>DataLen</code> : Length of data in bytes</li> </ul> <p>Returns:</p> <p>Number of bytes read </p>"},{"location":"Device/group__device__intrf/#function-deviceintrftxcomplete","title":"function DeviceIntrfTxComplete","text":"<p>Signal Tx transfer completed. </p> <pre><code>void DeviceIntrfTxComplete (\n    DevIntrf_t *const pDev\n) \n</code></pre> <p>This is useful for interrupt based transfer</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/group__device__intrf/#function-deviceintrfwrite","title":"function DeviceIntrfWrite","text":"<p>Device write transfer. </p> <pre><code>int DeviceIntrfWrite (\n    DevIntrf_t *const pDev,\n    uint32_t DevAddr,\n    uint8_t * pAdCmd,\n    int AdCmdLen,\n    uint8_t * pData,\n    int DataLen\n) \n</code></pre> <p>A device write transfer usually starts with a write of a command or register address. Then follows with a write data. This function encapsulate that functionality.</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> <li><code>DevAddr</code> : The device selection id scheme </li> <li><code>pAdCmd</code> : Pointer to buffer containing address or command code to send </li> <li><code>AdCmdLen</code> : Size of addr/Cmd in bytes </li> <li><code>pData</code> : Pointer to data to send. </li> <li><code>DataLen</code> : Length of data in bytes</li> </ul> <p>Returns:</p> <p>Number of bytes of data sent (not counting the Addr/Cmd). </p>"},{"location":"Device/group__device__intrf/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Device/group__device__intrf/#function-deviceintrfdisable","title":"function DeviceIntrfDisable","text":"<p>Disable interface. Put the interface in lowest power mode. </p> <pre><code>static inline void DeviceIntrfDisable (\n    DevIntrf_t *const pDev\n) \n</code></pre> <p>If this is a physical interface, provide a way to turn off for energy saving. Make sure the turn off procedure can be turned back on without going through the full initialization sequence</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/group__device__intrf/#function-deviceintrfenable","title":"function DeviceIntrfEnable","text":"<p>Wake up the interface. </p> <pre><code>static inline void DeviceIntrfEnable (\n    DevIntrf_t *const pDev\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/group__device__intrf/#function-deviceintrfgethandle","title":"function DeviceIntrfGetHandle","text":"<pre><code>static inline void * DeviceIntrfGetHandle (\n    DevIntrf_t *const pDev\n) \n</code></pre>"},{"location":"Device/group__device__intrf/#function-deviceintrfgetrate","title":"function DeviceIntrfGetRate","text":"<p>Get data rate of the interface in Hertz. This is not a clock frequency but rather the transfer frequency (number of transfers per second). It has meaning base on the implementation as bits/sec or bytes/sec or whatever the case. </p> <pre><code>static inline uint32_t DeviceIntrfGetRate (\n    DevIntrf_t *const pDev\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface</li> </ul> <p>Returns:</p> <p>Transfer rate per second </p>"},{"location":"Device/group__device__intrf/#function-deviceintrfgettype","title":"function DeviceIntrfGetType","text":"<p>Get interface type. </p> <pre><code>static inline DEVINTRF_TYPE DeviceIntrfGetType (\n    DevIntrf_t *const pDev\n) \n</code></pre> <p>Returns:</p> <p>Interface type </p>"},{"location":"Device/group__device__intrf/#function-deviceintrfpoweroff","title":"function DeviceIntrfPowerOff","text":"<p>Power off interface completely for power saving. </p> <pre><code>static inline void DeviceIntrfPowerOff (\n    DevIntrf_t *const pDev\n) \n</code></pre> <p>This function will power off the interface completely. Not all interface provides this type of functionality. Once power off is call, full initialization cycle is required. Therefore there is no PowerOn counter part of this function contrary to the Enable/Disable functions.</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/group__device__intrf/#function-deviceintrfreset","title":"function DeviceIntrfReset","text":"<p>This function perform a reset of interface. </p> <pre><code>static inline void DeviceIntrfReset (\n    DevIntrf_t *const pDev\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/group__device__intrf/#function-deviceintrfrxdata","title":"function DeviceIntrfRxData","text":"<p>Receive data into pBuff passed in parameter. Assuming StartRx was called prior calling this function to get the actual data. </p> <pre><code>static inline int DeviceIntrfRxData (\n    DevIntrf_t *const pDev,\n    uint8_t * pBuff,\n    int BuffLen\n) \n</code></pre> <p>Return -1 in case of interrupt based or transfer without waiting for completion. for example I2C where stop condition is handled asynchronously</p> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> <li><code>pBuff</code> : Pointer to memory area to receive data. </li> <li><code>BuffLen</code> : Length of buffer memory in bytes</li> </ul> <p>Returns:</p> <p>Number of bytes read -1 special case for interrupt driven without waiting for completion for example I2C where stop condition is handled asynchronously </p>"},{"location":"Device/group__device__intrf/#function-deviceintrfsetrate","title":"function DeviceIntrfSetRate","text":"<p>Set data rate of the interface in Hertz. </p> <pre><code>static inline uint32_t DeviceIntrfSetRate (\n    DevIntrf_t *const pDev,\n    uint32_t Rate\n) \n</code></pre> <p>This is not a clock frequency but rather the transfer frequency (number of transfers per second). It has meaning base on the implementation as bits/sec or bytes/sec or whatever the case</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> <li><code>Rate</code> : Data rate to be set in Hertz (transfer per second)</li> </ul> <p>Returns:</p> <p>Actual transfer rate per second set. It is the real capable rate closest to rate being requested. </p>"},{"location":"Device/group__device__intrf/#function-deviceintrfstartrx","title":"function DeviceIntrfStartRx","text":"<p>Prepare start condition to receive data with subsequence RxData. </p> <pre><code>static inline bool DeviceIntrfStartRx (\n    DevIntrf_t *const pDev,\n    uint32_t DevAddr\n) \n</code></pre> <p>This can be in case such as start condition for I2C or Chip Select for SPI or precondition for DMA transfer or whatever requires it or not This function must check &amp; set the busy state for re-entrancy</p> <p>NOTE: On success StopRx must be called to release busy flag</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> <li><code>DevAddr</code> : The device selection id scheme</li> </ul> <p>Returns:</p> <p>true - Success  false - failed. </p>"},{"location":"Device/group__device__intrf/#function-deviceintrfstarttx","title":"function DeviceIntrfStartTx","text":"<p>Prepare start condition to transfer data with subsequence TxData. </p> <pre><code>static inline bool DeviceIntrfStartTx (\n    DevIntrf_t *const pDev,\n    uint32_t DevAddr\n) \n</code></pre> <p>This can be in case such as start condition for I2C or Chip Select for SPI or precondition for DMA transfer or whatever requires it or not This function must check &amp; set the busy state for re-entrancy</p> <p>On success StopRx must be called to release busy flag</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> <li><code>DevAddr</code> : The device selection id scheme</li> </ul> <p>Returns:</p> <p>true - Success  false - failed </p>"},{"location":"Device/group__device__intrf/#function-deviceintrfstoprx","title":"function DeviceIntrfStopRx","text":"<p>Completion of read data phase. </p> <pre><code>static inline void DeviceIntrfStopRx (\n    DevIntrf_t *const pDev\n) \n</code></pre> <p>Do require post processing after data has been received via RxData This function must clear the busy state for re-entrancy</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/group__device__intrf/#function-deviceintrfstoptx","title":"function DeviceIntrfStopTx","text":"<p>Completion of sending data via TxData. </p> <pre><code>static inline void DeviceIntrfStopTx (\n    DevIntrf_t *const pDev\n) \n</code></pre> <p>Perform the require post processing after all data was transmitted via TxData. This function must clear the busy state for re-entrancy</p> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/group__device__intrf/#function-deviceintrftxdata","title":"function DeviceIntrfTxData","text":"<p>Transfer data from pData passed in parameter. Assuming StartTx was called prior calling this function to send the actual data. </p> <pre><code>static inline int DeviceIntrfTxData (\n    DevIntrf_t *const pDev,\n    uint8_t * pData,\n    int DataLen\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pDev</code> : Pointer to an instance of the Device Interface </li> <li><code>pData</code> : Pointer to memory area of data to send. </li> <li><code>DataLen</code> : Length of data memory in bytes</li> </ul> <p>Returns:</p> <p>Number of bytes sent </p>"},{"location":"Device/struct____device__intrf/","title":"Struct __device_intrf","text":"<p>ClassList &gt; __device_intrf</p> <p>Device interface data structure. More...</p> <ul> <li><code>#include &lt;device_intrf.h&gt;</code></li> </ul>"},{"location":"Device/struct____device__intrf/#public-attributes","title":"Public Attributes","text":"Type Name void(* Disable Put the interface to sleep for maximum energy saving. atomic_int EnCnt void(* Enable Wake up the interface. DevIntrfEvtHandler_t EvtCB Interrupt based event callback function pointer. Must be set to NULL if not used. void *(* GetHandle uint32_t(* GetRate Get data rate of the interface in Hertz. This is not a clock frequency but rather the transfer frequency (number of transfers per second). It has meaning base on the implementation as bits/sec or bytes/sec or whatever the case. int IntPrio Interrupt priority. Value is implementation specific. int MaxRetry Max retry when data could not be transfered (Rx/Tx returns zero count) void(* PowerOff Power off device for power saving. void(* Reset This function perform a reset of interface. Must provide empty function of not used. int(* RxData Receive data into pBuff passed in parameter. Assuming StartRx was called prior calling this function to get the actual data. uint32_t(* SetRate Set data rate of the interface in Hertz. This is not a clock frequency but rather the transfer frequency (number of transfers per second). It has meaning base on the implementation as bits/sec or bytes/sec or whatever the case. bool(* StartRx Prepare start condition to receive data with subsequence RxData. This can be in case such as start condition for I2C or Chip Select for SPI or precondition for DMA transfer or whatever requires it or not This function must check &amp; set the busy state for re-entrancy. bool(* StartTx Prepare start condition to transfer data with subsequence TxData. This can be in case such as start condition for I2C or Chip Select for SPI or precondition for DMA transfer or whatever requires it or not This function must check &amp; set the busy state for re-entrancy. void(* StopRx Completion of read data phase. Do require post processing after data has been received via RxData This function must clear the busy state for reentrancy. void(* StopTx Completion of sending data via TxData. Do require post processing after all data was transmitted via TxData. This function must clear the busy state for re-entrancy. int(* TxData Transfer data from pData passed in parameter. Assuming StartTx was called prior calling this function to send the actual data. int(* TxSrData Transfer data from pData passed in parameter with re-start. DEVINTRF_TYPE Type Identify the type of interface. atomic_flag bBusy Busy flag to be set check and set at start and reset at end of transmission. bool bDma Enable DMA transfer support. Not all hardware interface supports this feature. bool bIntEn Enable interrupt support. Not all hardware interface supports this feature. atomic_bool bNoStop atomic_bool bTxReady Flag indicating Tx is ready for transfer. void * pDevData Private device interface implementation data."},{"location":"Device/struct____device__intrf/#detailed-description","title":"Detailed Description","text":"<p>This structure is the actual interface for both C++ &amp; C code It is used to provide C compatibility instead of using C++ interface which is only for C++</p> <p>This data structure is visible for implementer of interface. It is seen as handle for application to pass to the interface function calls. Application firmware should not access any member of this structure directly. </p>"},{"location":"Device/struct____device__intrf/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Device/struct____device__intrf/#variable-disable","title":"variable Disable","text":"<p>Put the interface to sleep for maximum energy saving. </p> <pre><code>void(* __device_intrf::Disable) (DevIntrf_t *const pDevIntrf);\n</code></pre> <p>If this is a physical interface, provide a way to put the interface to sleep for maximum energy saving possible. This function must be implemented in such a way that the interface can be re-enable without going through full initialization sequence.</p> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/struct____device__intrf/#variable-encnt","title":"variable EnCnt","text":"<pre><code>atomic_int __device_intrf::EnCnt;\n</code></pre> <p>Count the number of time device is enabled, this used as ref count where multiple devices are using the same interface. It is to avoid it being disabled while another device is still using it </p>"},{"location":"Device/struct____device__intrf/#variable-enable","title":"variable Enable","text":"<p>Wake up the interface. </p> <pre><code>void(* __device_intrf::Enable) (DevIntrf_t *const pDevIntrf);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/struct____device__intrf/#variable-evtcb","title":"variable EvtCB","text":"<pre><code>DevIntrfEvtHandler_t __device_intrf::EvtCB;\n</code></pre>"},{"location":"Device/struct____device__intrf/#variable-gethandle","title":"variable GetHandle","text":"<pre><code>void *(* __device_intrf::GetHandle) (DevIntrf_t *const pDevIntrf);\n</code></pre>"},{"location":"Device/struct____device__intrf/#variable-getrate","title":"variable GetRate","text":"<p>Get data rate of the interface in Hertz. This is not a clock frequency but rather the transfer frequency (number of transfers per second). It has meaning base on the implementation as bits/sec or bytes/sec or whatever the case. </p> <pre><code>uint32_t(* __device_intrf::GetRate) (DevIntrf_t *const pDevIntrf);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface</li> </ul> <p>Returns:</p> <p>Transfer rate per second </p>"},{"location":"Device/struct____device__intrf/#variable-intprio","title":"variable IntPrio","text":"<pre><code>int __device_intrf::IntPrio;\n</code></pre>"},{"location":"Device/struct____device__intrf/#variable-maxretry","title":"variable MaxRetry","text":"<pre><code>int __device_intrf::MaxRetry;\n</code></pre>"},{"location":"Device/struct____device__intrf/#variable-poweroff","title":"variable PowerOff","text":"<p>Power off device for power saving. </p> <pre><code>void(* __device_intrf::PowerOff) (DevIntrf_t *const pDevIntrf);\n</code></pre> <p>This function will power off device completely. Not all device provide this type of functionality. Once power off is call, full initialization cycle is required. Therefore their is no PowerOn counter part of this function contrary to the Enable/Disable functions.</p> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/struct____device__intrf/#variable-reset","title":"variable Reset","text":"<p>This function perform a reset of interface. Must provide empty function of not used. </p> <pre><code>void(* __device_intrf::Reset) (DevIntrf_t *const pDevIntrf);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/struct____device__intrf/#variable-rxdata","title":"variable RxData","text":"<p>Receive data into pBuff passed in parameter. Assuming StartRx was called prior calling this function to get the actual data. </p> <pre><code>int(* __device_intrf::RxData) (DevIntrf_t *const pDevIntrf, uint8_t *pBuff, int BuffLen);\n</code></pre> <p>Return -1 in case of interrupt based or transfer without waiting for completion. for example I2C where stop condition is handled asynchronously</p> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> <li><code>pBuff</code> : Pointer to memory area to receive data. </li> <li><code>BuffLen</code> : Length of buffer memory in bytes</li> </ul> <p>Returns:</p> <p>Number of bytes read -1 special case for interrupt driven without waiting for completion for example I2C where stop condition is handled asynchronously </p>"},{"location":"Device/struct____device__intrf/#variable-setrate","title":"variable SetRate","text":"<p>Set data rate of the interface in Hertz. This is not a clock frequency but rather the transfer frequency (number of transfers per second). It has meaning base on the implementation as bits/sec or bytes/sec or whatever the case. </p> <pre><code>uint32_t(* __device_intrf::SetRate) (DevIntrf_t *const pDevIntrf, uint32_t Rate);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> <li><code>Rate</code> : Data rate to be set in Hertz (transfer per second)</li> </ul> <p>Returns:</p> <p>Actual transfer rate per second set. It is the real capable rate closest to rate being requested. </p>"},{"location":"Device/struct____device__intrf/#variable-startrx","title":"variable StartRx","text":"<p>Prepare start condition to receive data with subsequence RxData. This can be in case such as start condition for I2C or Chip Select for SPI or precondition for DMA transfer or whatever requires it or not This function must check &amp; set the busy state for re-entrancy. </p> <pre><code>bool(* __device_intrf::StartRx) (DevIntrf_t *const pDevIntrf, uint32_t DevAddr);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> <li><code>DevAddr</code> : The device selection id scheme</li> </ul> <p>Returns:</p> <p>true - Success  false - failed. </p>"},{"location":"Device/struct____device__intrf/#variable-starttx","title":"variable StartTx","text":"<p>Prepare start condition to transfer data with subsequence TxData. This can be in case such as start condition for I2C or Chip Select for SPI or precondition for DMA transfer or whatever requires it or not This function must check &amp; set the busy state for re-entrancy. </p> <pre><code>bool(* __device_intrf::StartTx) (DevIntrf_t *const pDevIntrf, uint32_t DevAddr);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> <li><code>DevAddr</code> : The device selection id scheme</li> </ul> <p>Returns:</p> <p>true - Success  false - failed </p>"},{"location":"Device/struct____device__intrf/#variable-stoprx","title":"variable StopRx","text":"<p>Completion of read data phase. Do require post processing after data has been received via RxData This function must clear the busy state for reentrancy. </p> <pre><code>void(* __device_intrf::StopRx) (DevIntrf_t *const pDevIntrf);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/struct____device__intrf/#variable-stoptx","title":"variable StopTx","text":"<p>Completion of sending data via TxData. Do require post processing after all data was transmitted via TxData. This function must clear the busy state for re-entrancy. </p> <pre><code>void(* __device_intrf::StopTx) (DevIntrf_t *const pDevIntrf);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> </ul>"},{"location":"Device/struct____device__intrf/#variable-txdata","title":"variable TxData","text":"<p>Transfer data from pData passed in parameter. Assuming StartTx was called prior calling this function to send the actual data. </p> <pre><code>int(* __device_intrf::TxData) (DevIntrf_t *const pDevIntrf, uint8_t *pData, int DataLen);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> <li><code>pData</code> : Pointer to memory area of data to send. </li> <li><code>DataLen</code> : Length of data memory in bytes</li> </ul> <p>Returns:</p> <p>Number of bytes sent </p>"},{"location":"Device/struct____device__intrf/#variable-txsrdata","title":"variable TxSrData","text":"<p>Transfer data from pData passed in parameter with re-start. </p> <pre><code>int(* __device_intrf::TxSrData) (DevIntrf_t *const pDevIntrf, uint8_t *pData, int DataLen);\n</code></pre> <p>Assuming StartTx was called prior calling this function to send the actual data. This is a special function for some I2C devices that requires writing the data into a special register for write-restart-read sequence. One of such MCU is the Atmel SAM series. The data length in this case cannot exceed 4 bytes.</p> <p>Parameters:</p> <ul> <li><code>pDevIntrf</code> : Pointer to an instance of the Device Interface </li> <li><code>pData</code> : Pointer to memory area of data to send. </li> <li><code>DataLen</code> : Length of data memory in bytes</li> </ul> <p>Returns:</p> <p>Number of bytes sent </p>"},{"location":"Device/struct____device__intrf/#variable-type","title":"variable Type","text":"<pre><code>DEVINTRF_TYPE __device_intrf::Type;\n</code></pre>"},{"location":"Device/struct____device__intrf/#variable-bbusy","title":"variable bBusy","text":"<pre><code>atomic_flag __device_intrf::bBusy;\n</code></pre>"},{"location":"Device/struct____device__intrf/#variable-bdma","title":"variable bDma","text":"<pre><code>bool __device_intrf::bDma;\n</code></pre>"},{"location":"Device/struct____device__intrf/#variable-binten","title":"variable bIntEn","text":"<pre><code>bool __device_intrf::bIntEn;\n</code></pre>"},{"location":"Device/struct____device__intrf/#variable-bnostop","title":"variable bNoStop","text":"<pre><code>atomic_bool __device_intrf::bNoStop;\n</code></pre> <p>Flag indicating a continous transfer. Usually used for read/write register value or cmd/response type. This flag is relevant only when interrupt is enabled async transfer </p>"},{"location":"Device/struct____device__intrf/#variable-btxready","title":"variable bTxReady","text":"<pre><code>atomic_bool __device_intrf::bTxReady;\n</code></pre>"},{"location":"Device/struct____device__intrf/#variable-pdevdata","title":"variable pDevData","text":"<pre><code>void* __device_intrf::pDevData;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/device_intrf.h</code></p>"},{"location":"Device/dir_d44c64559bbebec7f509842c48db8b23/","title":"Dir include","text":"<p>FileList &gt; include</p>"},{"location":"Device/dir_d44c64559bbebec7f509842c48db8b23/#files","title":"Files","text":"Type Name file device.h Generic device base class. file device_intrf.h Generic data transfer interface class. <p>The documentation for this class was generated from the following file <code>include/</code></p>"},{"location":"Device/device_8h/","title":"File device.h","text":"<p>FileList &gt; include &gt; device.h</p> <p>Go to the source code of this file</p> <p>Generic device base class. More...</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include \"coredev/iopincfg.h\"</code></li> <li><code>#include \"coredev/timer.h\"</code></li> <li><code>#include \"device_intrf.h\"</code></li> </ul>"},{"location":"Device/device_8h/#public-types","title":"Public Types","text":"Type Name typedef enum __Dev_Interrupt_Polarity DEVINTR_POL Defines interrupt pin polarity of the device. typedef enum __Device_Event DEV_EVT enum __Dev_Interrupt_Polarity Defines interrupt pin polarity of the device. enum __Device_Event"},{"location":"Device/device_8h/#detailed-description","title":"Detailed Description","text":"<p>This is the base class to implement all sort devices, hardware or software. For example a sensor device or a software audio/video decoder. The device can transfer data via it's DeviceIntrf object.</p> <p>Important NOTE : For performance, there is no pointer or parameter validation at this low level layer. It is the responsibility of caller to pre-validate all access</p> <p>Author:</p> <p>Hoang Nguyen Hoan </p> <p>Date:</p> <p>Feb. 12, 2017</p> <p>@license</p> <p>Copyright (c) 2017, I-SYST inc., all rights reserved</p> <p>Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies, and none of the names : I-SYST or its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p> <p>For info or contributing contact : hnhoan at i-syst dot com</p> <p>THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"Device/device_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Device/device_8h/#typedef-devintr_pol","title":"typedef DEVINTR_POL","text":"<p>Defines interrupt pin polarity of the device. </p> <pre><code>typedef enum __Dev_Interrupt_Polarity DEVINTR_POL;\n</code></pre> <p>Many hardware devices can have interrupt pin polarity configurable. </p>"},{"location":"Device/device_8h/#typedef-dev_evt","title":"typedef DEV_EVT","text":"<pre><code>typedef enum __Device_Event DEV_EVT;\n</code></pre>"},{"location":"Device/device_8h/#enum-__dev_interrupt_polarity","title":"enum __Dev_Interrupt_Polarity","text":"<p>Defines interrupt pin polarity of the device. </p> <pre><code>enum __Dev_Interrupt_Polarity {\n    DEVINTR_POL_LOW,\n    DEVINTR_POL_HIGH\n};\n</code></pre> <p>Many hardware devices can have interrupt pin polarity configurable. </p>"},{"location":"Device/device_8h/#enum-__device_event","title":"enum __Device_Event","text":"<pre><code>enum __Device_Event {\n    DEV_EVT_DATA_RDY\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/device.h</code></p>"},{"location":"Device/device_8h_source/","title":"File device.h","text":"<p>File List &gt; include &gt; device.h</p> <p>Go to the documentation of this file</p> <pre><code>\n#ifndef __DEVICE_H__\n#define __DEVICE_H__\n\n#include &lt;stdint.h&gt;\n\n#ifndef __cplusplus\n#include &lt;stdbool.h&gt;\n#endif\n\n#include \"coredev/iopincfg.h\"\n#include \"coredev/timer.h\"\n#include \"device_intrf.h\"\n\ntypedef enum __Dev_Interrupt_Polarity {\n    DEVINTR_POL_LOW,    \n    DEVINTR_POL_HIGH    \n} DEVINTR_POL;\n\ntypedef enum __Device_Event {\n    DEV_EVT_DATA_RDY\n} DEV_EVT;\n\n#ifdef __cplusplus\n\nclass Device;\n\ntypedef void (*DevEvtHandler_t)(Device * const pDev, DEV_EVT Evt);\n//typedef DevEvtHandler_t       DEVEVTCB;\n\nclass Device {\npublic:\n    Device();\n    virtual ~Device() {}\n\n    //\n    // *** Require implementations ***\n    //\n\n    virtual bool Enable() = 0;\n\n    virtual void Disable() = 0;\n\n    virtual void Reset() = 0;\n\n    //\n    // *** Optional implementations ***\n    //\n\n    virtual void PowerOff() {}\n\n    virtual void DeviceAddress(uint32_t Addr) { vDevAddr =  Addr; }\n\n    virtual uint32_t DeviceAddress() { return vDevAddr; }\n\n    virtual uint64_t DeviceID() { return vDevId; }\n\n    virtual int Read(uint8_t *pCmdAddr, int CmdAddrLen, uint8_t *pBuff, int BuffLen);\n\n    virtual int Write(uint8_t *pCmdAddr, int CmdAddrLen, uint8_t *pData, int DataLen);\n\n    virtual uint8_t Read8(uint8_t *pRegAddr, int RegAddrLen) {\n        uint8_t val = 0;\n        Read(pRegAddr, RegAddrLen, &amp;val, 1);\n        return val;\n    }\n\n    virtual uint16_t Read16(uint8_t *pRegAddr, int RegAddrLen) {\n        uint16_t val = 0;\n        Read(pRegAddr, RegAddrLen,(uint8_t*) &amp;val, 2);\n        return val;\n    }\n\n    virtual uint32_t Read32(uint8_t *pRegAddr, int RegAddrLen) {\n        uint32_t val = 0;\n        Read(pRegAddr, RegAddrLen, (uint8_t*)&amp;val, 4);\n        return val;\n    }\n\n    virtual bool Write8(uint8_t *pRegAddr, int RegAddrLen, uint8_t Data) {\n        return Write(pRegAddr, RegAddrLen, &amp;Data, 1) &gt; 0;\n    }\n\n    virtual bool Write16(uint8_t *pRegAddr, int RegAddrLen, uint16_t Data) {\n        return Write(pRegAddr, RegAddrLen, (uint8_t*)&amp;Data, 2) &gt; 1;\n    }\n\n    virtual bool Write32(uint8_t *pRegAddr, int RegAddrLen, uint32_t Data) {\n        return Write(pRegAddr, RegAddrLen, (uint8_t*)&amp;Data, 1) &gt; 3;\n    }\n\n    bool Valid() { return vbValid; }\n\n    DEVINTRF_TYPE InterfaceType() { return vpIntrf != nullptr ? vpIntrf-&gt;Type() : DEVINTRF_TYPE_UNKOWN; }\n\n    virtual operator Timer * const () { return vpTimer; }   // Get device interface data (handle)\n\n    void SetEvtHandler(DevEvtHandler_t EvtHandler) { vEvtHandler = EvtHandler; }\n    virtual void EvtHandler(DEV_EVT Evt) { if (vEvtHandler) vEvtHandler(this, Evt); }\n\nprotected:\n\n    void DeviceID(uint64_t DevId) { vDevId = DevId; }\n\n    void Valid(bool bVal) { vbValid = bVal; }\n\n    void Interface(DeviceIntrf * const pIntrf) { vpIntrf = pIntrf; }\n\n    DeviceIntrf * const Interface() { return vpIntrf; }\n\n    void InterruptEnabled(bool En) { vbIntEn = En; }\n    bool InterruptEnabled() { return vbIntEn; }\n\n    bool        vbValid;        \n    uint32_t    vDevAddr;       \n    DeviceIntrf *vpIntrf;       \n    Timer       *vpTimer;       \n    uint64_t    vDevId;         \n    bool        vbIntEn;        \n    DevEvtHandler_t vEvtHandler;    \n};\n\nextern \"C\" {\n#endif  // __cplusplus\n\n\n#ifdef __cplusplus\n}\n\n#endif  // __cplusplus\n\n#endif  // __DEVICE_H__\n</code></pre>"},{"location":"Device/device__intrf_8h/","title":"File device_intrf.h","text":"<p>FileList &gt; include &gt; device_intrf.h</p> <p>Go to the source code of this file</p> <p>Generic data transfer interface class. More...</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;stdatomic.h&gt;</code></li> </ul>"},{"location":"Device/device__intrf_8h/#classes","title":"Classes","text":"Type Name struct __device_intrf Device interface data structure."},{"location":"Device/device__intrf_8h/#detailed-description","title":"Detailed Description","text":"<p>This class is used to implement device communication interfaces such as I2C, UART, etc... Not limited to wired or physical interface. It could be soft interface as well such as SLIP protocol or any mean of transferring data between 2 entities.</p> <p>Author:</p> <p>Hoang Nguyen Hoan </p> <p>Date:</p> <p>Nov. 25, 2011</p> <p>@license</p> <p>Copyright (c) 2011, I-SYST inc., all rights reserved</p> <p>Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies, and none of the names : I-SYST or its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p> <p>For info or contributing contact : hnhoan at i-syst dot com</p> <p>THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p> <p>The documentation for this class was generated from the following file <code>include/device_intrf.h</code></p>"},{"location":"Device/device__intrf_8h_source/","title":"File device_intrf.h","text":"<p>File List &gt; include &gt; device_intrf.h</p> <p>Go to the documentation of this file</p> <pre><code>\n#ifndef __DEVICEINTRF_H__\n#define __DEVICEINTRF_H__\n\n#include &lt;stdint.h&gt;\n\n#ifdef __cplusplus\n    #include &lt;atomic&gt;\n    using namespace std;\n#else\n#include &lt;stdbool.h&gt;\n#include &lt;stdatomic.h&gt;\n#endif\n\ntypedef enum {\n    DEVINTRF_EVT_RX_TIMEOUT,    \n    DEVINTRF_EVT_RX_DATA,       \n    DEVINTRF_EVT_RX_FIFO_FULL,  \n    DEVINTRF_EVT_TX_TIMEOUT,    \n    DEVINTRF_EVT_TX_READY,      \n    DEVINTRF_EVT_TX_FIFO_EMPTY, \n    DEVINTRF_EVT_STATECHG,      \n    DEVINTRF_EVT_READ_RQST,     \n    DEVINTRF_EVT_WRITE_RQST,    \n    DEVINTRF_EVT_COMPLETED,     \n} DEVINTRF_EVT;\n\ntypedef enum __Dev_Intrf_Type {\n    DEVINTRF_TYPE_UNKOWN,       \n    DEVINTRF_TYPE_BT,          \n    DEVINTRF_TYPE_ETH,          \n    DEVINTRF_TYPE_I2C,          \n    DEVINTRF_TYPE_CEL,          \n    DEVINTRF_TYPE_SPI,          \n    DEVINTRF_TYPE_QSPI,         \n    DEVINTRF_TYPE_UART,         \n    DEVINTRF_TYPE_USB,          \n    DEVINTRF_TYPE_WIFI,         \n    DEVINTRF_TYPE_I2S,          \n    DEVINTRF_TYPE_PDM,          \n    DEVINTRF_TYPE_OSPI,         \n} DEVINTRF_TYPE;\n\ntypedef struct __device_intrf DevIntrf_t;\n\ntypedef int (*DevIntrfEvtHandler_t)(DevIntrf_t * const pDev, DEVINTRF_EVT EvtId, uint8_t *pBuffer, int Len);\n\n#pragma pack(push, 4)\n\nstruct __device_intrf {\n    void *pDevData;             \n    int IntPrio;                \n    DevIntrfEvtHandler_t EvtCB; \n    atomic_flag bBusy;          \n    int MaxRetry;               \n    atomic_int EnCnt;           \n    DEVINTRF_TYPE Type;         \n    bool bDma;                  \n    bool bIntEn;                \n    atomic_bool bTxReady;       \n    atomic_bool bNoStop;        \n    // Bellow are all mandatory functions to implement\n    // On init, all implementation must fill these function, no NULL allowed\n    // If a function is not used. It must be implemented as do nothing function\n\n    void (*Disable)(DevIntrf_t * const pDevIntrf);\n\n    void (*Enable)(DevIntrf_t * const pDevIntrf);\n\n    uint32_t (*GetRate)(DevIntrf_t * const pDevIntrf);\n\n    uint32_t (*SetRate)(DevIntrf_t * const pDevIntrf, uint32_t Rate);\n\n    bool (*StartRx)(DevIntrf_t * const pDevIntrf, uint32_t DevAddr);\n\n    int (*RxData)(DevIntrf_t * const pDevIntrf, uint8_t *pBuff, int BuffLen);\n\n    void (*StopRx)(DevIntrf_t * const pDevIntrf);\n\n    bool (*StartTx)(DevIntrf_t * const pDevIntrf, uint32_t DevAddr);\n\n    int (*TxData)(DevIntrf_t * const pDevIntrf, uint8_t *pData, int DataLen);\n\n    int (*TxSrData)(DevIntrf_t * const pDevIntrf, uint8_t *pData, int DataLen);\n\n    void (*StopTx)(DevIntrf_t * const pDevIntrf);\n\n    void (*Reset)(DevIntrf_t * const pDevIntrf);\n\n    void (*PowerOff)(DevIntrf_t * const pDevIntrf);\n\n    void *(*GetHandle)(DevIntrf_t * const pDevIntrf);\n};\n\n#pragma pack(pop)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic inline void DeviceIntrfDisable(DevIntrf_t * const pDev) {\n    if (atomic_exchange(&amp;pDev-&gt;EnCnt, pDev-&gt;EnCnt - 1) &lt; 1) {\n//  if (--pDev-&gt;EnCnt &lt; 1) {\n        pDev-&gt;Disable(pDev);\n        pDev-&gt;EnCnt = 0;\n    }\n}\n\nstatic inline void DeviceIntrfEnable(DevIntrf_t * const pDev) {\n    if (atomic_exchange(&amp;pDev-&gt;EnCnt, pDev-&gt;EnCnt + 1) == 1)    {\n//  if (++pDev-&gt;EnCnt == 1) {\n        pDev-&gt;Enable(pDev);\n    }\n}\n\nstatic inline uint32_t DeviceIntrfGetRate(DevIntrf_t * const pDev) {\n    return pDev-&gt;GetRate(pDev);\n}\n\nstatic inline uint32_t DeviceIntrfSetRate(DevIntrf_t * const pDev, uint32_t Rate) {\n    return pDev-&gt;SetRate(pDev, Rate);\n}\n\nint DeviceIntrfRx(DevIntrf_t * const pDev, uint32_t DevAddr, uint8_t *pBuff, int BuffLen);\n\nint DeviceIntrfTx(DevIntrf_t * const pDev, uint32_t DevAddr, uint8_t *pData, int DataLen);\n\nvoid DeviceIntrfTxComplete(DevIntrf_t * const pDev);\n\nint DeviceIntrfRead(DevIntrf_t * const pDev, uint32_t DevAddr, uint8_t *pAdCmd, int AdCmdLen,\n                    uint8_t *pRxBuff, int RxLen);\n\nint DeviceIntrfWrite(DevIntrf_t * const pDev, uint32_t DevAddr, uint8_t *pAdCmd, int AdCmdLen,\n                     uint8_t *pData, int DataLen);\n\nstatic inline bool DeviceIntrfStartRx(DevIntrf_t * const pDev, uint32_t DevAddr) {\n    if (atomic_flag_test_and_set(&amp;pDev-&gt;bBusy))\n        return false;\n\n    bool retval = pDev-&gt;StartRx(pDev, DevAddr);\n\n    // In case of returned false, app would not call Stop to release busy flag\n    // so we need to do that here before returning\n    if (retval == false) {\n        atomic_flag_clear(&amp;pDev-&gt;bBusy);\n    }\n\n    return retval;\n}\n\nstatic inline int DeviceIntrfRxData(DevIntrf_t * const pDev, uint8_t *pBuff, int BuffLen) {\n    return pDev-&gt;RxData(pDev, pBuff, BuffLen);\n}\n\nstatic inline void DeviceIntrfStopRx(DevIntrf_t * const pDev) {\n    pDev-&gt;StopRx(pDev);\n    atomic_flag_clear(&amp;pDev-&gt;bBusy);\n}\n\n// Initiate receive\n// WARNING this function must be used in pair with StopTx\n// Re-entrance protection flag is used\n// On success, StopTx must be after transmission is completed to release flag\nstatic inline bool DeviceIntrfStartTx(DevIntrf_t * const pDev, uint32_t DevAddr) {\n    if (atomic_flag_test_and_set(&amp;pDev-&gt;bBusy))\n        return false;\n\n    bool retval =  pDev-&gt;StartTx(pDev, DevAddr);\n\n    // In case of returned false, app would not call Stop to release busy flag\n    // so we need to do that here before returning\n    if (retval == false) {\n        atomic_flag_clear(&amp;pDev-&gt;bBusy);\n    }\n\n    return retval;\n}\n\nstatic inline int DeviceIntrfTxData(DevIntrf_t * const pDev, uint8_t *pData, int DataLen) {\n    return pDev-&gt;TxData(pDev, pData, DataLen);\n}\n\nstatic inline void DeviceIntrfStopTx(DevIntrf_t * const pDev) {\n    pDev-&gt;StopTx(pDev);\n    atomic_flag_clear(&amp;pDev-&gt;bBusy);\n}\n\nstatic inline void DeviceIntrfReset(DevIntrf_t * const pDev) {\n    if (pDev-&gt;Reset)\n        pDev-&gt;Reset(pDev);\n}\n\nstatic inline void DeviceIntrfPowerOff(DevIntrf_t * const pDev) {\n    if (pDev-&gt;PowerOff) pDev-&gt;PowerOff(pDev);\n}\n\nstatic inline DEVINTRF_TYPE DeviceIntrfGetType(DevIntrf_t * const pDev) {\n    return pDev-&gt;Type;\n}\n\nstatic inline void *DeviceIntrfGetHandle(DevIntrf_t * const pDev) {\n    return pDev-&gt;GetHandle(pDev);\n}\n\n#ifdef __cplusplus\n}\n\n\nclass DeviceIntrf {\npublic:\n\n    virtual operator DevIntrf_t * const () = 0; // Get device interface data (handle)\n\n    virtual DEVINTRF_TYPE Type() { return DeviceIntrfGetType(*this); }\n\n    virtual uint32_t Rate(uint32_t DataRate) = 0;\n\n    virtual uint32_t Rate(void) = 0;\n\n    virtual void Disable(void) { DeviceIntrfDisable(*this); }\n\n    virtual void Enable(void) { DeviceIntrfEnable(*this); }\n\n    void PowerOff() { DeviceIntrfPowerOff(*this); }\n\n    virtual int Rx(uint32_t DevAddr, uint8_t *pBuff, int BuffLen) {\n        return DeviceIntrfRx(*this,DevAddr, pBuff, BuffLen);\n    }\n\n    virtual int Tx(uint32_t DevAddr, uint8_t *pData, int DataLen) {\n        return DeviceIntrfTx(*this, DevAddr, pData, DataLen);\n    }\n\n    virtual int Read(uint32_t DevAddr, uint8_t *pAdCmd, int AdCmdLen, uint8_t *pBuff, int BuffLen) {\n        return DeviceIntrfRead(*this, DevAddr, pAdCmd, AdCmdLen, pBuff, BuffLen);\n    }\n\n    virtual int Write(uint32_t DevAddr, uint8_t *pAdCmd, int AdCmdLen, uint8_t *pData, int DataLen) {\n        return DeviceIntrfWrite(*this, DevAddr, pAdCmd, AdCmdLen, pData, DataLen);\n    }\n\n    // Initiate receive\n    // WARNING this function must be used in pair with StopRx\n    // Re-entrance protection flag is used\n    // On success, StopRx must be after transmission is completed to release flag\n    virtual bool StartRx(uint32_t DevAddr) = 0;\n\n    virtual int RxData(uint8_t *pBuff, int BuffLen) = 0;\n\n    virtual void StopRx(void) = 0;\n\n    // Initiate transmit\n    // WARNING this function must be used in pair with StopTx\n    // Re-entrance protection flag is used\n    // On success, StopTx must be after transmission is completed to release flag\n    virtual bool StartTx(uint32_t DevAddr) = 0;\n\n    virtual int TxData(uint8_t *pData, int DataLen) = 0;\n\n    // Stop transmit\n    // WARNING !!!!!\n    // This functions MUST ONLY be called if StartTx returns true.\n    virtual void StopTx(void) = 0;\n\n    virtual bool RequestToSend(int NbBytes) { return true; }\n\n    virtual void Reset(void) { DeviceIntrfReset(*this); }\n};\n\n#endif\n\n#endif  // __DEVICEINTRF_H__\n</code></pre>"},{"location":"Device/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"Device/classes/","title":"Class Index","text":"<p>## \\</p> <ul> <li>__device_intrf</li> </ul>"},{"location":"Device/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>struct __device_intrf Device interface data structure. </li> </ul>"},{"location":"Device/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p> <ul> <li>Device Interface </li> </ul>"},{"location":"Device/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Device/class_members/","title":"Class Members","text":""},{"location":"Device/class_members/#b","title":"b","text":"<ul> <li>bBusy (__device_intrf)</li> <li>bDma (__device_intrf)</li> <li>bIntEn (__device_intrf)</li> <li>bNoStop (__device_intrf)</li> <li>bTxReady (__device_intrf)</li> </ul>"},{"location":"Device/class_members/#d","title":"d","text":"<ul> <li>Disable (__device_intrf)</li> </ul>"},{"location":"Device/class_members/#e","title":"e","text":"<ul> <li>EnCnt (__device_intrf)</li> <li>Enable (__device_intrf)</li> <li>EvtCB (__device_intrf)</li> </ul>"},{"location":"Device/class_members/#g","title":"g","text":"<ul> <li>GetHandle (__device_intrf)</li> <li>GetRate (__device_intrf)</li> </ul>"},{"location":"Device/class_members/#i","title":"i","text":"<ul> <li>IntPrio (__device_intrf)</li> </ul>"},{"location":"Device/class_members/#m","title":"m","text":"<ul> <li>MaxRetry (__device_intrf)</li> </ul>"},{"location":"Device/class_members/#p","title":"p","text":"<ul> <li>PowerOff (__device_intrf)</li> <li>pDevData (__device_intrf)</li> </ul>"},{"location":"Device/class_members/#r","title":"r","text":"<ul> <li>Reset (__device_intrf)</li> <li>RxData (__device_intrf)</li> </ul>"},{"location":"Device/class_members/#s","title":"s","text":"<ul> <li>SetRate (__device_intrf)</li> <li>StartRx (__device_intrf)</li> <li>StartTx (__device_intrf)</li> <li>StopRx (__device_intrf)</li> <li>StopTx (__device_intrf)</li> </ul>"},{"location":"Device/class_members/#t","title":"t","text":"<ul> <li>TxData (__device_intrf)</li> <li>TxSrData (__device_intrf)</li> <li>Type (__device_intrf)</li> </ul>"},{"location":"Device/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"Device/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Device/class_member_variables/#b","title":"b","text":"<ul> <li>bBusy (__device_intrf)</li> <li>bDma (__device_intrf)</li> <li>bIntEn (__device_intrf)</li> <li>bNoStop (__device_intrf)</li> <li>bTxReady (__device_intrf)</li> </ul>"},{"location":"Device/class_member_variables/#d","title":"d","text":"<ul> <li>Disable (__device_intrf)</li> </ul>"},{"location":"Device/class_member_variables/#e","title":"e","text":"<ul> <li>EnCnt (__device_intrf)</li> <li>Enable (__device_intrf)</li> <li>EvtCB (__device_intrf)</li> </ul>"},{"location":"Device/class_member_variables/#g","title":"g","text":"<ul> <li>GetHandle (__device_intrf)</li> <li>GetRate (__device_intrf)</li> </ul>"},{"location":"Device/class_member_variables/#i","title":"i","text":"<ul> <li>IntPrio (__device_intrf)</li> </ul>"},{"location":"Device/class_member_variables/#m","title":"m","text":"<ul> <li>MaxRetry (__device_intrf)</li> </ul>"},{"location":"Device/class_member_variables/#p","title":"p","text":"<ul> <li>PowerOff (__device_intrf)</li> <li>pDevData (__device_intrf)</li> </ul>"},{"location":"Device/class_member_variables/#r","title":"r","text":"<ul> <li>Reset (__device_intrf)</li> <li>RxData (__device_intrf)</li> </ul>"},{"location":"Device/class_member_variables/#s","title":"s","text":"<ul> <li>SetRate (__device_intrf)</li> <li>StartRx (__device_intrf)</li> <li>StartTx (__device_intrf)</li> <li>StopRx (__device_intrf)</li> <li>StopTx (__device_intrf)</li> </ul>"},{"location":"Device/class_member_variables/#t","title":"t","text":"<ul> <li>TxData (__device_intrf)</li> <li>TxSrData (__device_intrf)</li> <li>Type (__device_intrf)</li> </ul>"},{"location":"Device/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Device/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Device/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Device/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Device/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Device/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Device/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Device/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Device/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Device/variables/","title":"Variables","text":""},{"location":"Device/variables/#d","title":"d","text":"<ul> <li>DEVINTR_POL (device.h)</li> <li>DEV_EVT (device.h)</li> </ul>"},{"location":"Device/variables/#_","title":"_","text":"<ul> <li>__Dev_Interrupt_Polarity (device.h)</li> <li>__Device_Event (device.h)</li> </ul>"},{"location":"Device/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}